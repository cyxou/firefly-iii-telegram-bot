/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v1.5.6
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2022-04-04T03:54:41+00:00 
 *
 * The version of the OpenAPI document: 1.5.6
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AttachmentArray } from '../model';
// @ts-ignore
import { Category } from '../model';
// @ts-ignore
import { CategoryArray } from '../model';
// @ts-ignore
import { CategorySingle } from '../model';
// @ts-ignore
import { CategoryUpdate } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { TransactionTypeFilter } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (id: string, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByCategory: async (id: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategory: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is per 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCategory: async (id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions without a category, possibly limited by start and end
         * @summary All transactions without a category.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutCategory: async (limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/categories/transactions-without-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCategory: async (category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('storeCategory', 'category', category)
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, categoryUpdate: CategoryUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            // verify required parameter 'categoryUpdate' is not null or undefined
            assertParamExists('updateCategory', 'categoryUpdate', categoryUpdate)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(id: string, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(id, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByCategory(id: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByCategory(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategory(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategory(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is per 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByCategory(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByCategory(id, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions without a category, possibly limited by start and end
         * @summary All transactions without a category.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionWithoutCategory(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionWithoutCategory(limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeCategory(category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeCategory(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, categoryUpdate: CategoryUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, categoryUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(id: string, start?: string, end?: string, options?: any): AxiosPromise<CategorySingle> {
            return localVarFp.getCategory(id, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByCategory(id: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByCategory(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategory(page?: number, options?: any): AxiosPromise<CategoryArray> {
            return localVarFp.listCategory(page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is per 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCategory(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByCategory(id, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions without a category, possibly limited by start and end
         * @summary All transactions without a category.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutCategory(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionWithoutCategory(limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCategory(category: Category, options?: any): AxiosPromise<CategorySingle> {
            return localVarFp.storeCategory(category, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, categoryUpdate: CategoryUpdate, options?: any): AxiosPromise<CategorySingle> {
            return localVarFp.updateCategory(id, categoryUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiDeleteCategoryRequest
 */
export interface CategoriesApiDeleteCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiDeleteCategory
     */
    readonly id: string
}

/**
 * Request parameters for getCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiGetCategoryRequest
 */
export interface CategoriesApiGetCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiGetCategory
     */
    readonly id: string

    /**
     * A date formatted YYYY-MM-DD, to show spent and earned info. 
     * @type {string}
     * @memberof CategoriesApiGetCategory
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to show spent and earned info. 
     * @type {string}
     * @memberof CategoriesApiGetCategory
     */
    readonly end?: string
}

/**
 * Request parameters for listAttachmentByCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiListAttachmentByCategoryRequest
 */
export interface CategoriesApiListAttachmentByCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiListAttachmentByCategory
     */
    readonly id: string

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof CategoriesApiListAttachmentByCategory
     */
    readonly page?: number
}

/**
 * Request parameters for listCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiListCategoryRequest
 */
export interface CategoriesApiListCategoryRequest {
    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof CategoriesApiListCategory
     */
    readonly page?: number
}

/**
 * Request parameters for listTransactionByCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiListTransactionByCategoryRequest
 */
export interface CategoriesApiListTransactionByCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly id: string

    /**
     * Page number. The default pagination is per 50.
     * @type {number}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD, to limit the result list. 
     * @type {string}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to limit the result list. 
     * @type {string}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned
     * @type {TransactionTypeFilter}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for listTransactionWithoutCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiListTransactionWithoutCategoryRequest
 */
export interface CategoriesApiListTransactionWithoutCategoryRequest {
    /**
     * Limits the number of results on one page.
     * @type {number}
     * @memberof CategoriesApiListTransactionWithoutCategory
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof CategoriesApiListTransactionWithoutCategory
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof CategoriesApiListTransactionWithoutCategory
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof CategoriesApiListTransactionWithoutCategory
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned
     * @type {TransactionTypeFilter}
     * @memberof CategoriesApiListTransactionWithoutCategory
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for storeCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiStoreCategoryRequest
 */
export interface CategoriesApiStoreCategoryRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
     * @type {Category}
     * @memberof CategoriesApiStoreCategory
     */
    readonly category: Category
}

/**
 * Request parameters for updateCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiUpdateCategoryRequest
 */
export interface CategoriesApiUpdateCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiUpdateCategory
     */
    readonly id: string

    /**
     * JSON array with updated category information. See the model for the exact specifications.
     * @type {CategoryUpdate}
     * @memberof CategoriesApiUpdateCategory
     */
    readonly categoryUpdate: CategoryUpdate
}

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Delete a category. Transactions will not be removed.
     * @summary Delete a category.
     * @param {CategoriesApiDeleteCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public deleteCategory(requestParameters: CategoriesApiDeleteCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).deleteCategory(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single category.
     * @summary Get a single category.
     * @param {CategoriesApiGetCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategory(requestParameters: CategoriesApiGetCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).getCategory(requestParameters.id, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {CategoriesApiListAttachmentByCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listAttachmentByCategory(requestParameters: CategoriesApiListAttachmentByCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).listAttachmentByCategory(requestParameters.id, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all categories.
     * @summary List all categories.
     * @param {CategoriesApiListCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listCategory(requestParameters: CategoriesApiListCategoryRequest = {}, options?: any) {
        return CategoriesApiFp(this.configuration).listCategory(requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions in a category, optionally limited to the date ranges specified.
     * @summary List all transactions in a category.
     * @param {CategoriesApiListTransactionByCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listTransactionByCategory(requestParameters: CategoriesApiListTransactionByCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).listTransactionByCategory(requestParameters.id, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions without a category, possibly limited by start and end
     * @summary All transactions without a category.
     * @param {CategoriesApiListTransactionWithoutCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listTransactionWithoutCategory(requestParameters: CategoriesApiListTransactionWithoutCategoryRequest = {}, options?: any) {
        return CategoriesApiFp(this.configuration).listTransactionWithoutCategory(requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new category
     * @param {CategoriesApiStoreCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public storeCategory(requestParameters: CategoriesApiStoreCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).storeCategory(requestParameters.category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing category.
     * @summary Update existing category.
     * @param {CategoriesApiUpdateCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public updateCategory(requestParameters: CategoriesApiUpdateCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).updateCategory(requestParameters.id, requestParameters.categoryUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}
