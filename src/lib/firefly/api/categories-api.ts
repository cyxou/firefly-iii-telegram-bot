/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v2.0.10
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2023-10-15T12:13:25+00:00  Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that. 
 *
 * The version of the OpenAPI document: 2.0.10
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AttachmentArray } from '../model';
// @ts-ignore
import { BadRequest } from '../model';
// @ts-ignore
import { Category } from '../model';
// @ts-ignore
import { CategoryArray } from '../model';
// @ts-ignore
import { CategorySingle } from '../model';
// @ts-ignore
import { CategoryUpdate } from '../model';
// @ts-ignore
import { InternalException } from '../model';
// @ts-ignore
import { NotFound } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { TransactionTypeFilter } from '../model';
// @ts-ignore
import { Unauthenticated } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (id: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategory', 'id', id)
            const localVarPath = `/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (id: string, xTraceId?: string, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCategory', 'id', id)
            const localVarPath = `/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByCategory: async (id: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByCategory', 'id', id)
            const localVarPath = `/v1/categories/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategory: async (xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCategory: async (id: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByCategory', 'id', id)
            const localVarPath = `/v1/categories/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCategory: async (category: Category, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('storeCategory', 'category', category)
            const localVarPath = `/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, categoryUpdate: CategoryUpdate, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            // verify required parameter 'categoryUpdate' is not null or undefined
            assertParamExists('updateCategory', 'categoryUpdate', categoryUpdate)
            const localVarPath = `/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(id: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(id, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(id: string, xTraceId?: string, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(id, xTraceId, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByCategory(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByCategory(id, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategory(xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategory(xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByCategory(id: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByCategory(id, xTraceId, limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeCategory(category: Category, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeCategory(category, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, categoryUpdate: CategoryUpdate, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, categoryUpdate, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: string, xTraceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(id: string, xTraceId?: string, start?: string, end?: string, options?: any): AxiosPromise<CategorySingle> {
            return localVarFp.getCategory(id, xTraceId, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByCategory(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByCategory(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategory(xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<CategoryArray> {
            return localVarFp.listCategory(xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCategory(id: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByCategory(id, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCategory(category: Category, xTraceId?: string, options?: any): AxiosPromise<CategorySingle> {
            return localVarFp.storeCategory(category, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, categoryUpdate: CategoryUpdate, xTraceId?: string, options?: any): AxiosPromise<CategorySingle> {
            return localVarFp.updateCategory(id, categoryUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiDeleteCategoryRequest
 */
export interface CategoriesApiDeleteCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiDeleteCategory
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CategoriesApiDeleteCategory
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for getCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiGetCategoryRequest
 */
export interface CategoriesApiGetCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiGetCategory
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CategoriesApiGetCategory
     */
    readonly xTraceId?: string

    /**
     * A date formatted YYYY-MM-DD, to show spent and earned info. 
     * @type {string}
     * @memberof CategoriesApiGetCategory
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to show spent and earned info. 
     * @type {string}
     * @memberof CategoriesApiGetCategory
     */
    readonly end?: string
}

/**
 * Request parameters for listAttachmentByCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiListAttachmentByCategoryRequest
 */
export interface CategoriesApiListAttachmentByCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiListAttachmentByCategory
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CategoriesApiListAttachmentByCategory
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CategoriesApiListAttachmentByCategory
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CategoriesApiListAttachmentByCategory
     */
    readonly page?: number
}

/**
 * Request parameters for listCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiListCategoryRequest
 */
export interface CategoriesApiListCategoryRequest {
    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CategoriesApiListCategory
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CategoriesApiListCategory
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CategoriesApiListCategory
     */
    readonly page?: number
}

/**
 * Request parameters for listTransactionByCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiListTransactionByCategoryRequest
 */
export interface CategoriesApiListTransactionByCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD, to limit the result list. 
     * @type {string}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to limit the result list. 
     * @type {string}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned
     * @type {TransactionTypeFilter}
     * @memberof CategoriesApiListTransactionByCategory
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for storeCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiStoreCategoryRequest
 */
export interface CategoriesApiStoreCategoryRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
     * @type {Category}
     * @memberof CategoriesApiStoreCategory
     */
    readonly category: Category

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CategoriesApiStoreCategory
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for updateCategory operation in CategoriesApi.
 * @export
 * @interface CategoriesApiUpdateCategoryRequest
 */
export interface CategoriesApiUpdateCategoryRequest {
    /**
     * The ID of the category.
     * @type {string}
     * @memberof CategoriesApiUpdateCategory
     */
    readonly id: string

    /**
     * JSON array with updated category information. See the model for the exact specifications.
     * @type {CategoryUpdate}
     * @memberof CategoriesApiUpdateCategory
     */
    readonly categoryUpdate: CategoryUpdate

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof CategoriesApiUpdateCategory
     */
    readonly xTraceId?: string
}

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Delete a category. Transactions will not be removed.
     * @summary Delete a category.
     * @param {CategoriesApiDeleteCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public deleteCategory(requestParameters: CategoriesApiDeleteCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).deleteCategory(requestParameters.id, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single category.
     * @summary Get a single category.
     * @param {CategoriesApiGetCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategory(requestParameters: CategoriesApiGetCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).getCategory(requestParameters.id, requestParameters.xTraceId, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {CategoriesApiListAttachmentByCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listAttachmentByCategory(requestParameters: CategoriesApiListAttachmentByCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).listAttachmentByCategory(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all categories.
     * @summary List all categories.
     * @param {CategoriesApiListCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listCategory(requestParameters: CategoriesApiListCategoryRequest = {}, options?: any) {
        return CategoriesApiFp(this.configuration).listCategory(requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions in a category, optionally limited to the date ranges specified.
     * @summary List all transactions in a category.
     * @param {CategoriesApiListTransactionByCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listTransactionByCategory(requestParameters: CategoriesApiListTransactionByCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).listTransactionByCategory(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new category
     * @param {CategoriesApiStoreCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public storeCategory(requestParameters: CategoriesApiStoreCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).storeCategory(requestParameters.category, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing category.
     * @summary Update existing category.
     * @param {CategoriesApiUpdateCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public updateCategory(requestParameters: CategoriesApiUpdateCategoryRequest, options?: any) {
        return CategoriesApiFp(this.configuration).updateCategory(requestParameters.id, requestParameters.categoryUpdate, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
