/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v2.0.10
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2023-10-15T12:13:25+00:00  Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that. 
 *
 * The version of the OpenAPI document: 2.0.10
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AttachmentArray } from '../model';
// @ts-ignore
import { BadRequest } from '../model';
// @ts-ignore
import { BudgetArray } from '../model';
// @ts-ignore
import { BudgetLimit } from '../model';
// @ts-ignore
import { BudgetLimitArray } from '../model';
// @ts-ignore
import { BudgetLimitSingle } from '../model';
// @ts-ignore
import { BudgetLimitStore } from '../model';
// @ts-ignore
import { BudgetSingle } from '../model';
// @ts-ignore
import { BudgetStore } from '../model';
// @ts-ignore
import { BudgetUpdate } from '../model';
// @ts-ignore
import { InternalException } from '../model';
// @ts-ignore
import { NotFound } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { TransactionTypeFilter } from '../model';
// @ts-ignore
import { Unauthenticated } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * BudgetsApi - axios parameter creator
 * @export
 */
export const BudgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget: async (id: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBudget', 'id', id)
            const localVarPath = `/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetLimit: async (id: string, limitId: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('deleteBudgetLimit', 'limitId', limitId)
            const localVarPath = `/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudget: async (id: string, xTraceId?: string, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBudget', 'id', id)
            const localVarPath = `/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetLimit: async (id: string, limitId: number, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('getBudgetLimit', 'limitId', limitId)
            const localVarPath = `/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBudget: async (id: string, xTraceId?: string, limit?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByBudget', 'id', id)
            const localVarPath = `/v1/budgets/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudget: async (xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all budget limits for for this date range. 
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimit: async (start: string, end: string, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('listBudgetLimit', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('listBudgetLimit', 'end', end)
            const localVarPath = `/v1/budget-limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByBudget: async (id: string, xTraceId?: string, start?: string, end?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listBudgetLimitByBudget', 'id', id)
            const localVarPath = `/v1/budgets/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudget: async (id: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByBudget', 'id', id)
            const localVarPath = `/v1/budgets/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudgetLimit: async (id: string, limitId: string, xTraceId?: string, limit?: number, page?: number, type?: TransactionTypeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('listTransactionByBudgetLimit', 'limitId', limitId)
            const localVarPath = `/v1/budgets/{id}/limits/{limitId}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudget: async (budgetStore: BudgetStore, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetStore' is not null or undefined
            assertParamExists('storeBudget', 'budgetStore', budgetStore)
            const localVarPath = `/v1/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudgetLimit: async (id: string, budgetLimitStore: BudgetLimitStore, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeBudgetLimit', 'id', id)
            // verify required parameter 'budgetLimitStore' is not null or undefined
            assertParamExists('storeBudgetLimit', 'budgetLimitStore', budgetLimitStore)
            const localVarPath = `/v1/budgets/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetLimitStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget: async (id: string, budgetUpdate: BudgetUpdate, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBudget', 'id', id)
            // verify required parameter 'budgetUpdate' is not null or undefined
            assertParamExists('updateBudget', 'budgetUpdate', budgetUpdate)
            const localVarPath = `/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetLimit: async (id: string, limitId: string, budgetLimit: BudgetLimit, xTraceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('updateBudgetLimit', 'limitId', limitId)
            // verify required parameter 'budgetLimit' is not null or undefined
            assertParamExists('updateBudgetLimit', 'budgetLimit', budgetLimit)
            const localVarPath = `/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            // authentication local_bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xTraceId !== undefined && xTraceId !== null) {
                localVarHeaderParameter['X-Trace-Id'] = String(JSON.stringify(xTraceId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetLimit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetsApi - functional programming interface
 * @export
 */
export const BudgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBudget(id: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBudget(id, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBudgetLimit(id: string, limitId: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBudgetLimit(id, limitId, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudget(id: string, xTraceId?: string, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudget(id, xTraceId, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudgetLimit(id: string, limitId: number, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudgetLimit(id, limitId, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByBudget(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByBudget(id, xTraceId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudget(xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudget(xTraceId, limit, page, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all budget limits for for this date range. 
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudgetLimit(start: string, end: string, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudgetLimit(start, end, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudgetLimitByBudget(id: string, xTraceId?: string, start?: string, end?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudgetLimitByBudget(id, xTraceId, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByBudget(id: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByBudget(id, xTraceId, limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByBudgetLimit(id: string, limitId: string, xTraceId?: string, limit?: number, page?: number, type?: TransactionTypeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByBudgetLimit(id, limitId, xTraceId, limit, page, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeBudget(budgetStore: BudgetStore, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeBudget(budgetStore, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeBudgetLimit(id: string, budgetLimitStore: BudgetLimitStore, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeBudgetLimit(id, budgetLimitStore, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBudget(id: string, budgetUpdate: BudgetUpdate, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBudget(id, budgetUpdate, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBudgetLimit(id: string, limitId: string, budgetLimit: BudgetLimit, xTraceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBudgetLimit(id, limitId, budgetLimit, xTraceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetsApi - factory interface
 * @export
 */
export const BudgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetsApiFp(configuration)
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget(id: string, xTraceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBudget(id, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetLimit(id: string, limitId: string, xTraceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBudgetLimit(id, limitId, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudget(id: string, xTraceId?: string, start?: string, end?: string, options?: any): AxiosPromise<BudgetSingle> {
            return localVarFp.getBudget(id, xTraceId, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetLimit(id: string, limitId: number, xTraceId?: string, options?: any): AxiosPromise<BudgetLimitSingle> {
            return localVarFp.getBudgetLimit(id, limitId, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBudget(id: string, xTraceId?: string, limit?: number, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByBudget(id, xTraceId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudget(xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, options?: any): AxiosPromise<BudgetArray> {
            return localVarFp.listBudget(xTraceId, limit, page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all budget limits for for this date range. 
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimit(start: string, end: string, xTraceId?: string, options?: any): AxiosPromise<BudgetLimitArray> {
            return localVarFp.listBudgetLimit(start, end, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByBudget(id: string, xTraceId?: string, start?: string, end?: string, options?: any): AxiosPromise<BudgetLimitArray> {
            return localVarFp.listBudgetLimitByBudget(id, xTraceId, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudget(id: string, xTraceId?: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByBudget(id, xTraceId, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {number} [limit] Number of items per page. The default pagination is per 50 items.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudgetLimit(id: string, limitId: string, xTraceId?: string, limit?: number, page?: number, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByBudgetLimit(id, limitId, xTraceId, limit, page, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudget(budgetStore: BudgetStore, xTraceId?: string, options?: any): AxiosPromise<BudgetSingle> {
            return localVarFp.storeBudget(budgetStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudgetLimit(id: string, budgetLimitStore: BudgetLimitStore, xTraceId?: string, options?: any): AxiosPromise<BudgetLimitSingle> {
            return localVarFp.storeBudgetLimit(id, budgetLimitStore, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget(id: string, budgetUpdate: BudgetUpdate, xTraceId?: string, options?: any): AxiosPromise<BudgetSingle> {
            return localVarFp.updateBudget(id, budgetUpdate, xTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {string} [xTraceId] Unique identifier associated with this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetLimit(id: string, limitId: string, budgetLimit: BudgetLimit, xTraceId?: string, options?: any): AxiosPromise<BudgetLimitSingle> {
            return localVarFp.updateBudgetLimit(id, limitId, budgetLimit, xTraceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiDeleteBudgetRequest
 */
export interface BudgetsApiDeleteBudgetRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiDeleteBudget
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiDeleteBudget
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for deleteBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiDeleteBudgetLimitRequest
 */
export interface BudgetsApiDeleteBudgetLimitRequest {
    /**
     * The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiDeleteBudgetLimit
     */
    readonly id: string

    /**
     * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiDeleteBudgetLimit
     */
    readonly limitId: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiDeleteBudgetLimit
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for getBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiGetBudgetRequest
 */
export interface BudgetsApiGetBudgetRequest {
    /**
     * The ID of the requested budget.
     * @type {string}
     * @memberof BudgetsApiGetBudget
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiGetBudget
     */
    readonly xTraceId?: string

    /**
     * A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
     * @type {string}
     * @memberof BudgetsApiGetBudget
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
     * @type {string}
     * @memberof BudgetsApiGetBudget
     */
    readonly end?: string
}

/**
 * Request parameters for getBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiGetBudgetLimitRequest
 */
export interface BudgetsApiGetBudgetLimitRequest {
    /**
     * The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiGetBudgetLimit
     */
    readonly id: string

    /**
     * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @type {number}
     * @memberof BudgetsApiGetBudgetLimit
     */
    readonly limitId: number

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiGetBudgetLimit
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for listAttachmentByBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListAttachmentByBudgetRequest
 */
export interface BudgetsApiListAttachmentByBudgetRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiListAttachmentByBudget
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiListAttachmentByBudget
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof BudgetsApiListAttachmentByBudget
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof BudgetsApiListAttachmentByBudget
     */
    readonly page?: number
}

/**
 * Request parameters for listBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListBudgetRequest
 */
export interface BudgetsApiListBudgetRequest {
    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiListBudget
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof BudgetsApiListBudget
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof BudgetsApiListBudget
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
     * @type {string}
     * @memberof BudgetsApiListBudget
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
     * @type {string}
     * @memberof BudgetsApiListBudget
     */
    readonly end?: string
}

/**
 * Request parameters for listBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListBudgetLimitRequest
 */
export interface BudgetsApiListBudgetLimitRequest {
    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListBudgetLimit
     */
    readonly start: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListBudgetLimit
     */
    readonly end: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiListBudgetLimit
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for listBudgetLimitByBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListBudgetLimitByBudgetRequest
 */
export interface BudgetsApiListBudgetLimitByBudgetRequest {
    /**
     * The ID of the requested budget.
     * @type {string}
     * @memberof BudgetsApiListBudgetLimitByBudget
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiListBudgetLimitByBudget
     */
    readonly xTraceId?: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListBudgetLimitByBudget
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListBudgetLimitByBudget
     */
    readonly end?: string
}

/**
 * Request parameters for listTransactionByBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListTransactionByBudgetRequest
 */
export interface BudgetsApiListTransactionByBudgetRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly id: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD. 
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly end?: string

    /**
     * Optional filter on the transaction type(s) returned
     * @type {TransactionTypeFilter}
     * @memberof BudgetsApiListTransactionByBudget
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for listTransactionByBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiListTransactionByBudgetLimitRequest
 */
export interface BudgetsApiListTransactionByBudgetLimitRequest {
    /**
     * The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly id: string

    /**
     * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly limitId: string

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly xTraceId?: string

    /**
     * Number of items per page. The default pagination is per 50 items.
     * @type {number}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly limit?: number

    /**
     * Page number. The default pagination is per 50 items.
     * @type {number}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly page?: number

    /**
     * Optional filter on the transaction type(s) returned
     * @type {TransactionTypeFilter}
     * @memberof BudgetsApiListTransactionByBudgetLimit
     */
    readonly type?: TransactionTypeFilter
}

/**
 * Request parameters for storeBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiStoreBudgetRequest
 */
export interface BudgetsApiStoreBudgetRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
     * @type {BudgetStore}
     * @memberof BudgetsApiStoreBudget
     */
    readonly budgetStore: BudgetStore

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiStoreBudget
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for storeBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiStoreBudgetLimitRequest
 */
export interface BudgetsApiStoreBudgetLimitRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiStoreBudgetLimit
     */
    readonly id: string

    /**
     * JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
     * @type {BudgetLimitStore}
     * @memberof BudgetsApiStoreBudgetLimit
     */
    readonly budgetLimitStore: BudgetLimitStore

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiStoreBudgetLimit
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for updateBudget operation in BudgetsApi.
 * @export
 * @interface BudgetsApiUpdateBudgetRequest
 */
export interface BudgetsApiUpdateBudgetRequest {
    /**
     * The ID of the budget.
     * @type {string}
     * @memberof BudgetsApiUpdateBudget
     */
    readonly id: string

    /**
     * JSON array with updated budget information. See the model for the exact specifications.
     * @type {BudgetUpdate}
     * @memberof BudgetsApiUpdateBudget
     */
    readonly budgetUpdate: BudgetUpdate

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiUpdateBudget
     */
    readonly xTraceId?: string
}

/**
 * Request parameters for updateBudgetLimit operation in BudgetsApi.
 * @export
 * @interface BudgetsApiUpdateBudgetLimitRequest
 */
export interface BudgetsApiUpdateBudgetLimitRequest {
    /**
     * The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiUpdateBudgetLimit
     */
    readonly id: string

    /**
     * The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @type {string}
     * @memberof BudgetsApiUpdateBudgetLimit
     */
    readonly limitId: string

    /**
     * JSON array with updated budget limit information. See the model for the exact specifications.
     * @type {BudgetLimit}
     * @memberof BudgetsApiUpdateBudgetLimit
     */
    readonly budgetLimit: BudgetLimit

    /**
     * Unique identifier associated with this request.
     * @type {string}
     * @memberof BudgetsApiUpdateBudgetLimit
     */
    readonly xTraceId?: string
}

/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
export class BudgetsApi extends BaseAPI {
    /**
     * Delete a budget. Transactions will not be deleted.
     * @summary Delete a budget.
     * @param {BudgetsApiDeleteBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public deleteBudget(requestParameters: BudgetsApiDeleteBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).deleteBudget(requestParameters.id, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a budget limit.
     * @summary Delete a budget limit.
     * @param {BudgetsApiDeleteBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public deleteBudgetLimit(requestParameters: BudgetsApiDeleteBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).deleteBudgetLimit(requestParameters.id, requestParameters.limitId, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
     * @summary Get a single budget.
     * @param {BudgetsApiGetBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudget(requestParameters: BudgetsApiGetBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).getBudget(requestParameters.id, requestParameters.xTraceId, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get single budget limit.
     * @param {BudgetsApiGetBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgetLimit(requestParameters: BudgetsApiGetBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).getBudgetLimit(requestParameters.id, requestParameters.limitId, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments of a budget.
     * @param {BudgetsApiListAttachmentByBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listAttachmentByBudget(requestParameters: BudgetsApiListAttachmentByBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listAttachmentByBudget(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
     * @summary List all budgets.
     * @param {BudgetsApiListBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listBudget(requestParameters: BudgetsApiListBudgetRequest = {}, options?: any) {
        return BudgetsApiFp(this.configuration).listBudget(requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all budget limits for for this date range. 
     * @summary Get list of budget limits by date
     * @param {BudgetsApiListBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listBudgetLimit(requestParameters: BudgetsApiListBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listBudgetLimit(requestParameters.start, requestParameters.end, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
     * @summary Get all limits for a budget.
     * @param {BudgetsApiListBudgetLimitByBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listBudgetLimitByBudget(requestParameters: BudgetsApiListBudgetLimitByBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listBudgetLimitByBudget(requestParameters.id, requestParameters.xTraceId, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions linked to a budget, possibly limited by start and end
     * @summary All transactions to a budget.
     * @param {BudgetsApiListTransactionByBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listTransactionByBudget(requestParameters: BudgetsApiListTransactionByBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listTransactionByBudget(requestParameters.id, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
     * @summary List all transactions by a budget limit ID.
     * @param {BudgetsApiListTransactionByBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listTransactionByBudgetLimit(requestParameters: BudgetsApiListTransactionByBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).listTransactionByBudgetLimit(requestParameters.id, requestParameters.limitId, requestParameters.xTraceId, requestParameters.limit, requestParameters.page, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new budget
     * @param {BudgetsApiStoreBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public storeBudget(requestParameters: BudgetsApiStoreBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).storeBudget(requestParameters.budgetStore, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Store a new budget limit under this budget.
     * @summary Store new budget limit.
     * @param {BudgetsApiStoreBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public storeBudgetLimit(requestParameters: BudgetsApiStoreBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).storeBudgetLimit(requestParameters.id, requestParameters.budgetLimitStore, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing budget. This endpoint cannot be used to set budget amount limits.
     * @summary Update existing budget.
     * @param {BudgetsApiUpdateBudgetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public updateBudget(requestParameters: BudgetsApiUpdateBudgetRequest, options?: any) {
        return BudgetsApiFp(this.configuration).updateBudget(requestParameters.id, requestParameters.budgetUpdate, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing budget limit.
     * @summary Update existing budget limit.
     * @param {BudgetsApiUpdateBudgetLimitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public updateBudgetLimit(requestParameters: BudgetsApiUpdateBudgetLimitRequest, options?: any) {
        return BudgetsApiFp(this.configuration).updateBudgetLimit(requestParameters.id, requestParameters.limitId, requestParameters.budgetLimit, requestParameters.xTraceId, options).then((request) => request(this.axios, this.basePath));
    }
}
