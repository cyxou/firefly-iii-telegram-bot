/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v1.5.6
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2022-04-04T03:54:41+00:00 
 *
 * The version of the OpenAPI document: 1.5.6
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { RuleArray } from '../model';
// @ts-ignore
import { RuleGroupArray } from '../model';
// @ts-ignore
import { RuleGroupSingle } from '../model';
// @ts-ignore
import { RuleGroupStore } from '../model';
// @ts-ignore
import { RuleGroupUpdate } from '../model';
// @ts-ignore
import { TransactionArray } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * RuleGroupsApi - axios parameter creator
 * @export
 */
export const RuleGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a rule group.
         * @summary Delete a rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRuleGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
         * @summary Fire the rule group on your transactions.
         * @param {string} id The ID of the rule group.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRuleGroup: async (id: string, start?: string, end?: string, accounts?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fireRuleGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}/trigger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single rule group. This does not include the rules. For that, see below.
         * @summary Get a single rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRuleGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List rules in this rule group.
         * @summary List rules in this rule group.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByGroup: async (id: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRuleByGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}/rules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all rule groups.
         * @summary List all rule groups.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleGroup: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/rule_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule group.
         * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRuleGroup: async (ruleGroupStore: RuleGroupStore, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleGroupStore' is not null or undefined
            assertParamExists('storeRuleGroup', 'ruleGroupStore', ruleGroupStore)
            const localVarPath = `/api/v1/rule_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleGroupStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule group. No changes will be made.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200. 
         * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow. 
         * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRuleGroup: async (id: string, page?: number, start?: string, end?: string, searchLimit?: number, triggeredLimit?: number, accounts?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testRuleGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (searchLimit !== undefined) {
                localVarQueryParameter['search_limit'] = searchLimit;
            }

            if (triggeredLimit !== undefined) {
                localVarQueryParameter['triggered_limit'] = triggeredLimit;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing rule group.
         * @summary Update existing rule group.
         * @param {string} id The ID of the rule group.
         * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRuleGroup: async (id: string, ruleGroupUpdate: RuleGroupUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRuleGroup', 'id', id)
            // verify required parameter 'ruleGroupUpdate' is not null or undefined
            assertParamExists('updateRuleGroup', 'ruleGroupUpdate', ruleGroupUpdate)
            const localVarPath = `/api/v1/rule_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleGroupUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleGroupsApi - functional programming interface
 * @export
 */
export const RuleGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuleGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a rule group.
         * @summary Delete a rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRuleGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRuleGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
         * @summary Fire the rule group on your transactions.
         * @param {string} id The ID of the rule group.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fireRuleGroup(id: string, start?: string, end?: string, accounts?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fireRuleGroup(id, start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single rule group. This does not include the rules. For that, see below.
         * @summary Get a single rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuleGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroupSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuleGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List rules in this rule group.
         * @summary List rules in this rule group.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuleByGroup(id: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuleByGroup(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all rule groups.
         * @summary List all rule groups.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuleGroup(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroupArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuleGroup(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule group.
         * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeRuleGroup(ruleGroupStore: RuleGroupStore, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroupSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeRuleGroup(ruleGroupStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule group. No changes will be made.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200. 
         * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow. 
         * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testRuleGroup(id: string, page?: number, start?: string, end?: string, searchLimit?: number, triggeredLimit?: number, accounts?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testRuleGroup(id, page, start, end, searchLimit, triggeredLimit, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing rule group.
         * @summary Update existing rule group.
         * @param {string} id The ID of the rule group.
         * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRuleGroup(id: string, ruleGroupUpdate: RuleGroupUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroupSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRuleGroup(id, ruleGroupUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuleGroupsApi - factory interface
 * @export
 */
export const RuleGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuleGroupsApiFp(configuration)
    return {
        /**
         * Delete a rule group.
         * @summary Delete a rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleGroup(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRuleGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
         * @summary Fire the rule group on your transactions.
         * @param {string} id The ID of the rule group.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRuleGroup(id: string, start?: string, end?: string, accounts?: Array<number>, options?: any): AxiosPromise<void> {
            return localVarFp.fireRuleGroup(id, start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single rule group. This does not include the rules. For that, see below.
         * @summary Get a single rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroup(id: string, options?: any): AxiosPromise<RuleGroupSingle> {
            return localVarFp.getRuleGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List rules in this rule group.
         * @summary List rules in this rule group.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByGroup(id: string, page?: number, options?: any): AxiosPromise<RuleArray> {
            return localVarFp.listRuleByGroup(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rule groups.
         * @summary List all rule groups.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleGroup(page?: number, options?: any): AxiosPromise<RuleGroupArray> {
            return localVarFp.listRuleGroup(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule group.
         * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRuleGroup(ruleGroupStore: RuleGroupStore, options?: any): AxiosPromise<RuleGroupSingle> {
            return localVarFp.storeRuleGroup(ruleGroupStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule group. No changes will be made.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200. 
         * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow. 
         * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRuleGroup(id: string, page?: number, start?: string, end?: string, searchLimit?: number, triggeredLimit?: number, accounts?: Array<number>, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.testRuleGroup(id, page, start, end, searchLimit, triggeredLimit, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing rule group.
         * @summary Update existing rule group.
         * @param {string} id The ID of the rule group.
         * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRuleGroup(id: string, ruleGroupUpdate: RuleGroupUpdate, options?: any): AxiosPromise<RuleGroupSingle> {
            return localVarFp.updateRuleGroup(id, ruleGroupUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteRuleGroup operation in RuleGroupsApi.
 * @export
 * @interface RuleGroupsApiDeleteRuleGroupRequest
 */
export interface RuleGroupsApiDeleteRuleGroupRequest {
    /**
     * The ID of the rule group.
     * @type {string}
     * @memberof RuleGroupsApiDeleteRuleGroup
     */
    readonly id: string
}

/**
 * Request parameters for fireRuleGroup operation in RuleGroupsApi.
 * @export
 * @interface RuleGroupsApiFireRuleGroupRequest
 */
export interface RuleGroupsApiFireRuleGroupRequest {
    /**
     * The ID of the rule group.
     * @type {string}
     * @memberof RuleGroupsApiFireRuleGroup
     */
    readonly id: string

    /**
     * A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
     * @type {string}
     * @memberof RuleGroupsApiFireRuleGroup
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
     * @type {string}
     * @memberof RuleGroupsApiFireRuleGroup
     */
    readonly end?: string

    /**
     * Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
     * @type {Array<number>}
     * @memberof RuleGroupsApiFireRuleGroup
     */
    readonly accounts?: Array<number>
}

/**
 * Request parameters for getRuleGroup operation in RuleGroupsApi.
 * @export
 * @interface RuleGroupsApiGetRuleGroupRequest
 */
export interface RuleGroupsApiGetRuleGroupRequest {
    /**
     * The ID of the rule group.
     * @type {string}
     * @memberof RuleGroupsApiGetRuleGroup
     */
    readonly id: string
}

/**
 * Request parameters for listRuleByGroup operation in RuleGroupsApi.
 * @export
 * @interface RuleGroupsApiListRuleByGroupRequest
 */
export interface RuleGroupsApiListRuleByGroupRequest {
    /**
     * The ID of the rule group.
     * @type {string}
     * @memberof RuleGroupsApiListRuleByGroup
     */
    readonly id: string

    /**
     * Page number. The default pagination is 50.
     * @type {number}
     * @memberof RuleGroupsApiListRuleByGroup
     */
    readonly page?: number
}

/**
 * Request parameters for listRuleGroup operation in RuleGroupsApi.
 * @export
 * @interface RuleGroupsApiListRuleGroupRequest
 */
export interface RuleGroupsApiListRuleGroupRequest {
    /**
     * Page number. The default pagination is 50
     * @type {number}
     * @memberof RuleGroupsApiListRuleGroup
     */
    readonly page?: number
}

/**
 * Request parameters for storeRuleGroup operation in RuleGroupsApi.
 * @export
 * @interface RuleGroupsApiStoreRuleGroupRequest
 */
export interface RuleGroupsApiStoreRuleGroupRequest {
    /**
     * JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
     * @type {RuleGroupStore}
     * @memberof RuleGroupsApiStoreRuleGroup
     */
    readonly ruleGroupStore: RuleGroupStore
}

/**
 * Request parameters for testRuleGroup operation in RuleGroupsApi.
 * @export
 * @interface RuleGroupsApiTestRuleGroupRequest
 */
export interface RuleGroupsApiTestRuleGroupRequest {
    /**
     * The ID of the rule group.
     * @type {string}
     * @memberof RuleGroupsApiTestRuleGroup
     */
    readonly id: string

    /**
     * Page number. The default pagination is 50 items.
     * @type {number}
     * @memberof RuleGroupsApiTestRuleGroup
     */
    readonly page?: number

    /**
     * A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
     * @type {string}
     * @memberof RuleGroupsApiTestRuleGroup
     */
    readonly start?: string

    /**
     * A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
     * @type {string}
     * @memberof RuleGroupsApiTestRuleGroup
     */
    readonly end?: string

    /**
     * Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200. 
     * @type {number}
     * @memberof RuleGroupsApiTestRuleGroup
     */
    readonly searchLimit?: number

    /**
     * Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow. 
     * @type {number}
     * @memberof RuleGroupsApiTestRuleGroup
     */
    readonly triggeredLimit?: number

    /**
     * Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
     * @type {Array<number>}
     * @memberof RuleGroupsApiTestRuleGroup
     */
    readonly accounts?: Array<number>
}

/**
 * Request parameters for updateRuleGroup operation in RuleGroupsApi.
 * @export
 * @interface RuleGroupsApiUpdateRuleGroupRequest
 */
export interface RuleGroupsApiUpdateRuleGroupRequest {
    /**
     * The ID of the rule group.
     * @type {string}
     * @memberof RuleGroupsApiUpdateRuleGroup
     */
    readonly id: string

    /**
     * JSON array with updated rule group information. See the model for the exact specifications.
     * @type {RuleGroupUpdate}
     * @memberof RuleGroupsApiUpdateRuleGroup
     */
    readonly ruleGroupUpdate: RuleGroupUpdate
}

/**
 * RuleGroupsApi - object-oriented interface
 * @export
 * @class RuleGroupsApi
 * @extends {BaseAPI}
 */
export class RuleGroupsApi extends BaseAPI {
    /**
     * Delete a rule group.
     * @summary Delete a rule group.
     * @param {RuleGroupsApiDeleteRuleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public deleteRuleGroup(requestParameters: RuleGroupsApiDeleteRuleGroupRequest, options?: any) {
        return RuleGroupsApiFp(this.configuration).deleteRuleGroup(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
     * @summary Fire the rule group on your transactions.
     * @param {RuleGroupsApiFireRuleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public fireRuleGroup(requestParameters: RuleGroupsApiFireRuleGroupRequest, options?: any) {
        return RuleGroupsApiFp(this.configuration).fireRuleGroup(requestParameters.id, requestParameters.start, requestParameters.end, requestParameters.accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single rule group. This does not include the rules. For that, see below.
     * @summary Get a single rule group.
     * @param {RuleGroupsApiGetRuleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public getRuleGroup(requestParameters: RuleGroupsApiGetRuleGroupRequest, options?: any) {
        return RuleGroupsApiFp(this.configuration).getRuleGroup(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List rules in this rule group.
     * @summary List rules in this rule group.
     * @param {RuleGroupsApiListRuleByGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public listRuleByGroup(requestParameters: RuleGroupsApiListRuleByGroupRequest, options?: any) {
        return RuleGroupsApiFp(this.configuration).listRuleByGroup(requestParameters.id, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all rule groups.
     * @summary List all rule groups.
     * @param {RuleGroupsApiListRuleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public listRuleGroup(requestParameters: RuleGroupsApiListRuleGroupRequest = {}, options?: any) {
        return RuleGroupsApiFp(this.configuration).listRuleGroup(requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new rule group.
     * @param {RuleGroupsApiStoreRuleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public storeRuleGroup(requestParameters: RuleGroupsApiStoreRuleGroupRequest, options?: any) {
        return RuleGroupsApiFp(this.configuration).storeRuleGroup(requestParameters.ruleGroupStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
     * @summary Test which transactions would be hit by the rule group. No changes will be made.
     * @param {RuleGroupsApiTestRuleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public testRuleGroup(requestParameters: RuleGroupsApiTestRuleGroupRequest, options?: any) {
        return RuleGroupsApiFp(this.configuration).testRuleGroup(requestParameters.id, requestParameters.page, requestParameters.start, requestParameters.end, requestParameters.searchLimit, requestParameters.triggeredLimit, requestParameters.accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing rule group.
     * @summary Update existing rule group.
     * @param {RuleGroupsApiUpdateRuleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public updateRuleGroup(requestParameters: RuleGroupsApiUpdateRuleGroupRequest, options?: any) {
        return RuleGroupsApiFp(this.configuration).updateRuleGroup(requestParameters.id, requestParameters.ruleGroupUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}
